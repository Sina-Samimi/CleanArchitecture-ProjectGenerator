@using System
@using EndPoint.WebSite.Models.Test
@using Arsis.Application.Assessments
@using Arsis.Domain.Enums
@using System.Text.Json
@model TakeTestViewModel

@inject Microsoft.AspNetCore.Hosting.IWebHostEnvironment HostEnvironment
@{
    ViewData["Title"] = $"Ø§Ù†Ø¬Ø§Ù… Ø¢Ø²Ù…ÙˆÙ†: {Model.Test.Title}";
    var test = Model.Test;
    var questions = test.RandomizeQuestions 
        ? test.Questions.OrderBy(x => Guid.NewGuid()).ToList() 
        : test.Questions.OrderBy(q => q.Order).ToList();
    var isDevelopment = HostEnvironment.IsDevelopment();
}

<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                        <h5 class="mb-0">@test.Title</h5>
                        <div class="d-flex align-items-center gap-2">
                            @if (isDevelopment)
                            {
                                <button type="button" class="btn btn-warning btn-sm" onclick="autoCompleteTest(this)" title="ØªÚ©Ù…ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø§ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ÛŒ Ø±Ù†Ø¯ÙˆÙ… (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ ØªÙˆØ³Ø¹Ù‡)">
                                    <i class="bi bi-lightning-charge"></i> ØªÚ©Ù…ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø±
                                </button>
                            }
                            @if (Model.Attempt.ExpiresAt.HasValue)
                            {
                                <div id="timer" class="h5 mb-0">
                                    <i class="bi bi-clock"></i>
                                    <span id="timeRemaining"></span>
                                </div>
                            }
                        </div>
                    </div>
                    <div class="progress mt-2" style="height: 5px;">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                    <div class="mt-2 text-white-50 small" id="progressInfo">0 Ø§Ø² @questions.Count Ø³ÙˆØ§Ù„ Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª</div>
                </div>
                <div class="card-body">
                    @if (test.Type == TestType.CliftonSchwartz)
                    {
                        <div class="alert alert-info" role="alert">
                            Ø§ÛŒÙ† Ø¢Ø²Ù…ÙˆÙ† ØªØ±Ú©ÛŒØ¨ÛŒ Ø´Ø§Ù…Ù„ Ø¯Ùˆ Ø¨Ø®Ø´ Â«Clifton StrengthsÂ» Ùˆ Â«Schwartz PVQÂ» Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¨Ù‡ ØªØ±ØªÛŒØ¨ Ø¨Ù‡ Ù‡Ù…Ù‡ Ø³Ø¤Ø§Ù„Ø§Øª Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¹Ø¨Ø§Ø±Øª Ù…ÛŒØ²Ø§Ù† Ù…ÙˆØ§ÙÙ‚Øª ÛŒØ§ Ø´Ø¨Ø§Ù‡Øª Ø®ÙˆØ¯ Ø±Ø§ Ù…Ø´Ø®Øµ Ú©Ù†ÛŒØ¯.
                        </div>
                    }
                    <form id="testForm">
                        @Html.AntiForgeryToken()
                        <input type="hidden" name="attemptId" value="@Model.Attempt.Id" />

                        @for (int i = 0; i < questions.Count; i++)
                        {
                            var question = questions[i];
                            var existingAnswer = Model.Attempt.Answers.FirstOrDefault(a => a.QuestionId == question.Id);
                            var metadata = GetAssessmentMetadata(question.Explanation);
                            int scaleMin = metadata?.Min ?? 1;
                            int scaleMax = metadata?.Max ?? 5;
                            if (scaleMin > scaleMax)
                            {
                                var temp = scaleMin;
                                scaleMin = scaleMax;
                                scaleMax = temp;
                            }
                            var minLabel = !string.IsNullOrWhiteSpace(metadata?.MinLabel) ? metadata!.MinLabel! : "Ú©Ø§Ù…Ù„Ø§Ù‹ Ù…Ø®Ø§Ù„ÙÙ…";
                            var maxLabel = !string.IsNullOrWhiteSpace(metadata?.MaxLabel) ? metadata!.MaxLabel! : "Ú©Ø§Ù…Ù„Ø§Ù‹ Ù…ÙˆØ§ÙÙ‚Ù…";
                            var sectionLabel = GetAssessmentSectionLabel(metadata?.Assessment);
                            var dimensionLabel = metadata?.Dimension;
                            var existingLikertValue = existingAnswer?.LikertValue;
                            
                            <div class="question-container mb-5 p-4 border rounded-3" data-question-index="@i" data-question-id="@question.Id" data-required="@(question.IsRequired.ToString().ToLowerInvariant())" data-question-type="@question.QuestionType">
                                <h4 class="mb-4">
                                    Ø³ÙˆØ§Ù„ @(i + 1) Ø§Ø² @questions.Count
                                    @if (question.IsRequired)
                                    {
                                        <span class="text-danger">*</span>
                                    }
                                </h4>

                                  @if (!string.IsNullOrWhiteSpace(sectionLabel) || !string.IsNullOrWhiteSpace(dimensionLabel))
                                  {
                                      <div class="mb-3 d-flex flex-wrap gap-2">
                                          @if (!string.IsNullOrWhiteSpace(sectionLabel))
                                          {
                                              <span class="badge bg-info-subtle text-info fw-semibold">@sectionLabel</span>
                                          }
                                          @if (!string.IsNullOrWhiteSpace(dimensionLabel))
                                          {
                                              <span class="badge bg-light text-body-secondary border">@dimensionLabel</span>
                                          }
                                      </div>
                                  }

                                  <p class="lead">@question.Text</p>

                                @if (!string.IsNullOrEmpty(question.ImageUrl))
                                {
                                    <div class="mb-3">
                                        <img src="@question.ImageUrl" alt="Question image" class="img-fluid" style="max-height: 300px;" />
                                    </div>
                                }

                                @if (question.QuestionType == TestQuestionType.MultipleChoice)
                                {
                                    var options = test.RandomizeOptions 
                                        ? question.Options.OrderBy(x => Guid.NewGuid()).ToList()
                                        : question.Options.OrderBy(o => o.Order).ToList();
                                    
                                    <div class="list-group">
                                        @foreach (var option in options)
                                        {
                                            <label class="list-group-item list-group-item-action">
                                                <input type="radio" 
                                                       name="question_@question.Id" 
                                                       value="@option.Id" 
                                                       class="form-check-input me-2"
                                                       @(existingAnswer?.SelectedOptionId == option.Id ? "checked" : "") />
                                                @option.Text
                                            </label>
                                        }
                                    </div>
                                }
                                else if (question.QuestionType == TestQuestionType.TrueFalse)
                                {
                                    var trueChecked = string.Equals(existingAnswer?.TextAnswer, "true", StringComparison.OrdinalIgnoreCase);
                                    var falseChecked = string.Equals(existingAnswer?.TextAnswer, "false", StringComparison.OrdinalIgnoreCase);

                                    <div class="btn-group w-100" role="group">
                                        <input type="radio"
                                               class="btn-check"
                                               name="question_@question.Id"
                                               id="true_@question.Id"
                                               value="true"
                                               @(trueChecked ? "checked" : string.Empty)>
                                        <label class="btn btn-outline-success" for="true_@question.Id">Ø¯Ø±Ø³Øª</label>

                                        <input type="radio"
                                               class="btn-check"
                                               name="question_@question.Id"
                                               id="false_@question.Id"
                                               value="false"
                                               @(falseChecked ? "checked" : string.Empty)>
                                        <label class="btn btn-outline-danger" for="false_@question.Id">Ù†Ø§Ø¯Ø±Ø³Øª</label>
                                    </div>
                                }
                                  else if (question.QuestionType == TestQuestionType.LikertScale)
                                  {
                                      <div class="likert-scale text-center">
                                          <div class="d-flex justify-content-between mb-2">
                                              <span>@minLabel</span>
                                              <span>@maxLabel</span>
                                          </div>
                                          <div class="btn-group w-100" role="group">
                                              @for (var val = scaleMin; val <= scaleMax; val++)
                                              {
                                                  var inputId = $"likert_{question.Id}_{val}";
                                                  var isChecked = existingLikertValue.HasValue && existingLikertValue.Value == val;
                                                  <input type="radio" class="btn-check" name="question_@question.Id" id="@inputId" value="@val" @(isChecked ? "checked" : string.Empty)>
                                                  <label class="btn btn-outline-primary" for="@inputId">@val</label>
                                              }
                                          </div>
                                      </div>
                                }
                                else if (question.QuestionType == TestQuestionType.ShortText)
                                {
                                    <input type="text" 
                                           name="question_@question.Id" 
                                           class="form-control" 
                                           value="@existingAnswer?.TextAnswer"
                                           placeholder="Ù¾Ø§Ø³Ø® Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯..." />
                                }
                                else if (question.QuestionType == TestQuestionType.LongText)
                                {
                                    <textarea name="question_@question.Id" 
                                              class="form-control" 
                                              rows="5"
                                              placeholder="Ù¾Ø§Ø³Ø® Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯...">@existingAnswer?.TextAnswer</textarea>
                                }
                            </div>
                        }
                    </form>
                </div>
                <div class="card-footer">
                    <div class="d-flex justify-content-end">
                        <button type="button" id="submitBtn" class="btn btn-success btn-lg" onclick="completeTest()">
                            <i class="bi bi-check-circle"></i> Ù¾Ø§ÛŒØ§Ù† Ø¢Ø²Ù…ÙˆÙ† Ùˆ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù†ØªÛŒØ¬Ù‡
                        </button>
                    </div>
                </div>
            </div>
        </div>
</div>
</div>

<div id="completionOverlay" class="completion-overlay d-none" role="status" aria-live="polite">
    <div class="completion-dialog">
        <div class="completion-spinner"></div>
        <div class="completion-message">
            <h5>Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù†ØªÛŒØ¬Ù‡ Ø¢Ø²Ù…ÙˆÙ†</h5>
            <p class="text-muted mb-3">Ù„Ø·ÙØ§Ù‹ Ú†Ù†Ø¯ Ù„Ø­Ø¸Ù‡ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ØªØ§ ØªØ­Ù„ÛŒÙ„ ØªØ±Ú©ÛŒØ¨ÛŒ Ú©Ù„ÛŒÙØªÙˆÙ† Ùˆ Ø´ÙˆØ§Ø±ØªØ² Ø¢Ù…Ø§Ø¯Ù‡ Ø´ÙˆØ¯.</p>
        </div>
        <div class="completion-progress">
            <div class="completion-progress-bar">
                <div id="completionProgressFill" class="completion-progress-fill"></div>
            </div>
            <div class="completion-progress-text">
                <span id="completionProgressPercent">0%</span>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        const questionContainers = Array.from(document.querySelectorAll('.question-container'));
        const totalQuestions = questionContainers.length;
        const attemptId = '@Model.Attempt.Id';
        const token = document.querySelector('input[name="__RequestVerificationToken"]').value;
        const progressBar = document.getElementById('progressBar');
        const progressInfo = document.getElementById('progressInfo');
        const expiresAt = @(Model.Attempt.ExpiresAt.HasValue ? $"new Date('{Model.Attempt.ExpiresAt.Value:yyyy-MM-ddTHH:mm:ss}')" : "null");
        const completionOverlay = document.getElementById('completionOverlay');
        const completionProgressFill = document.getElementById('completionProgressFill');
        const completionProgressPercent = document.getElementById('completionProgressPercent');
        let completionProgressTimer = null;
        let completionProgressValue = 0;
        let isSubmitting = false;

        updateProgressBar();

        document.addEventListener('change', (event) => {
            if (!event.target.matches('input, textarea, select')) {
                return;
            }

            const container = event.target.closest('.question-container');
            if (!container) {
                return;
            }

            saveAnswer(container);
            if (isAnswered(container)) {
                container.classList.remove('border-danger');
            }
            updateProgressBar();
        });

        function collectAnswer(container) {
            const questionId = container.dataset.questionId;
            const questionType = container.dataset.questionType;
            let selectedOption = null;
            let textAnswer = null;
            let likertValue = null;

            const radio = container.querySelector(`input[name="question_${questionId}"]:checked`);
            if (radio) {
                const value = radio.value ?? '';
                if (value === 'true' || value === 'false') {
                    textAnswer = value;
                } else if (questionType === 'LikertScale') {
                    const numericValue = Number(value);
                    if (!Number.isNaN(numericValue)) {
                        likertValue = numericValue;
                    }
                } else {
                    selectedOption = value;
                }
            }

            const textInput = container.querySelector(`input[type="text"][name="question_${questionId}"]`);
            if (textInput && textInput.value.trim().length > 0) {
                textAnswer = textInput.value;
            }

            const textarea = container.querySelector(`textarea[name="question_${questionId}"]`);
            if (textarea && textarea.value.trim().length > 0) {
                textAnswer = textarea.value;
            }

            const hasSelectedOption = selectedOption !== null && selectedOption !== '';
            const hasTextAnswer = typeof textAnswer === 'string' && textAnswer.trim().length > 0;
            const hasLikertValue = likertValue !== null && !Number.isNaN(likertValue);

            return {
                questionId,
                selectedOption,
                textAnswer,
                likertValue,
                hasSelectedOption,
                hasTextAnswer,
                hasLikertValue
            };
        }

        async function saveAnswer(container) {
            const answer = collectAnswer(container);
            if (!answer) {
                console.log('âš ï¸ No answer collected');
                return true;
            }

            const { questionId, selectedOption, textAnswer, likertValue, hasSelectedOption, hasTextAnswer, hasLikertValue } = answer;

            if (!(hasSelectedOption || hasTextAnswer || hasLikertValue)) {
                console.log('âš ï¸ No valid answer data', { hasSelectedOption, hasTextAnswer, hasLikertValue });
                return true;
            }

            const formData = new FormData();
            formData.append('AttemptId', attemptId);
            formData.append('QuestionId', questionId);
            if (hasSelectedOption) {
                formData.append('SelectedOptionId', selectedOption);
            }
            if (hasTextAnswer) {
                formData.append('TextAnswer', textAnswer.trim());
            }
            if (hasLikertValue) {
                formData.append('LikertValue', likertValue);
            }
            formData.append('__RequestVerificationToken', token);

            console.log('ğŸ“¤ Sending answer:', {
                attemptId,
                questionId,
                selectedOption,
                textAnswer: textAnswer?.substring(0, 50),
                likertValue
            });

            try {
                const response = await fetch('@Url.Action("SubmitAnswer")', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    console.error('âŒ Failed to save answer: HTTP', response.status, response.statusText);
                    return false;
                }

                const data = await response.json();
                if (data.success) {
                    console.log('âœ… Answer saved successfully');
                    return true;
                }

                console.error('âŒ Failed to save answer:', data.error);
                return false;
            }
            catch (error) {
                console.error('âŒ Network error:', error);
                return false;
            }
        }

        function isAnswered(container) {
            const answer = collectAnswer(container);
            if (!answer) {
                return false;
            }

            return answer.hasSelectedOption || answer.hasTextAnswer || answer.hasLikertValue;
        }

        function updateProgressBar() {
            const answeredCount = questionContainers.filter(isAnswered).length;
            const progress = totalQuestions === 0 ? 0 : (answeredCount / totalQuestions) * 100;
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
            if (progressInfo) {
                progressInfo.textContent = `${answeredCount} Ø§Ø² ${totalQuestions} Ø³ÙˆØ§Ù„ Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª`;
            }
        }

        async function saveAllAnswers() {
            if (questionContainers.length === 0) {
                return true;
            }

            const failures = [];
            for (const container of questionContainers) {
                try {
                    const result = await saveAnswer(container);
                    if (result === false) {
                        failures.push(container.dataset.questionId || '[unknown]');
                    }
                } catch (error) {
                    console.error('âŒ Error while saving answer sequentially:', error);
                    failures.push(container.dataset.questionId || '[unknown]');
                }
            }

            if (failures.length > 0) {
                console.error('Failed to persist some answers before completing the test.', failures);
            }

            return failures.length === 0;
        }

        function validateBeforeSubmit() {
            for (const container of questionContainers) {
                const isRequired = container.dataset.required === 'true';
                if (isRequired && !isAnswered(container)) {
                    container.classList.add('border-danger');
                    container.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    alert('Ù„Ø·ÙØ§Ù‹ Ø¨Ù‡ ØªÙ…Ø§Ù… Ø³ÙˆØ§Ù„Ø§Øª Ø§Ù„Ø²Ø§Ù…ÛŒ Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯.');
                    return false;
                }
            }
            return true;
        }

        function updateCompletionProgress(value) {
            if (!completionProgressFill || !completionProgressPercent) {
                return;
            }

            const clampedValue = Math.max(0, Math.min(100, Math.round(value)));
            completionProgressFill.style.width = `${clampedValue}%`;
            completionProgressPercent.textContent = `${clampedValue}%`;
        }

        function startCompletionOverlay() {
            if (!completionOverlay) {
                return;
            }

            completionOverlay.classList.remove('d-none');
            requestAnimationFrame(() => completionOverlay.classList.add('completion-overlay--active'));
            completionProgressValue = 0;
            updateCompletionProgress(0);

            if (completionProgressTimer) {
                clearInterval(completionProgressTimer);
            }

            completionProgressTimer = window.setInterval(() => {
                if (completionProgressValue >= 92) {
                    return;
                }

                const increment = Math.max(1, Math.round((100 - completionProgressValue) * 0.08));
                completionProgressValue = Math.min(92, completionProgressValue + increment);
                updateCompletionProgress(completionProgressValue);
            }, 600);
        }

        function finishCompletionOverlay() {
            if (completionProgressTimer) {
                clearInterval(completionProgressTimer);
                completionProgressTimer = null;
            }

            completionProgressValue = 100;
            updateCompletionProgress(completionProgressValue);
        }

        function hideCompletionOverlay() {
            if (!completionOverlay) {
                return;
            }

            if (completionProgressTimer) {
                clearInterval(completionProgressTimer);
                completionProgressTimer = null;
            }

            completionOverlay.classList.remove('completion-overlay--active');
            setTimeout(() => {
                completionOverlay.classList.add('d-none');
            }, 250);
        }

        async function completeTest() {
            if (isSubmitting) {
                return;
            }

            if (!validateBeforeSubmit()) {
                return;
            }

            if (!confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¢Ø²Ù…ÙˆÙ† Ø±Ø§ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯ØŸ')) {
                return;
            }

            startCompletionOverlay();
            isSubmitting = true;
            const submitButton = document.getElementById('submitBtn');
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.classList.add('disabled');
            }

            const allAnswersSaved = await saveAllAnswers();
            if (!allAnswersSaved) {
                alert('Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø±Ø®ÛŒ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯. Ù„Ø·ÙØ§Ù‹ Ù„Ø­Ø¸Ø§ØªÛŒ Ø¨Ø¹Ø¯ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.classList.remove('disabled');
                }
                hideCompletionOverlay();
                isSubmitting = false;
                return;
            }

            const form = document.createElement('form');
            form.method = 'POST';
            form.action = '@Url.Action("Complete")';

            const tokenInput = document.createElement('input');
            tokenInput.type = 'hidden';
            tokenInput.name = '__RequestVerificationToken';
            tokenInput.value = token;
            form.appendChild(tokenInput);

            const attemptIdInput = document.createElement('input');
            attemptIdInput.type = 'hidden';
            attemptIdInput.name = 'attemptId';
            attemptIdInput.value = attemptId;
            form.appendChild(attemptIdInput);

            document.body.appendChild(form);
            finishCompletionOverlay();
            setTimeout(() => form.submit(), 150);
        }

        if (expiresAt) {
            setInterval(() => {
                const now = new Date();
                const remaining = Math.max(0, Math.floor((expiresAt - now) / 1000));

                if (remaining === 0) {
                    alert('Ø²Ù…Ø§Ù† Ø¢Ø²Ù…ÙˆÙ† Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª.');
                    completeTest();
                    return;
                }

                const minutes = Math.floor(remaining / 60);
                const seconds = remaining % 60;
                const timerEl = document.getElementById('timeRemaining');
                if (timerEl) {
                    timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        window.completeTest = completeTest;

        // Auto-complete function for development
        async function autoCompleteTest(buttonElement) {
            if (!confirm('Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù‡Ù…Ù‡ Ø³ÙˆØ§Ù„Ø§Øª Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø§ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ÛŒ Ø±Ù†Ø¯ÙˆÙ… ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯ØŸ\n\nâš ï¸ Ø§ÛŒÙ† Ø¹Ù…Ù„Ú©Ø±Ø¯ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ùˆ ØªÙˆØ³Ø¹Ù‡ Ø§Ø³Øª!')) {
                return;
            }

            const autoCompleteBtn = buttonElement instanceof HTMLElement
                ? buttonElement
                : document.querySelector('button[onclick*="autoCompleteTest"]');

            const originalButtonLabel = autoCompleteBtn ? autoCompleteBtn.innerHTML : '';

            if (autoCompleteBtn) {
                autoCompleteBtn.disabled = true;
                autoCompleteBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...';
            }

            let answeredCount = 0;
            const totalCount = questionContainers.length;

            // Process questions with a delay to prevent database overload
            console.log(`ğŸš€ Starting auto-complete for ${questionContainers.length} questions...`);

            try {
                for (let i = 0; i < questionContainers.length; i++) {
                    const container = questionContainers[i];

                    // Skip if already answered
                    if (isAnswered(container)) {
                        continue;
                    }

                    const questionId = container.dataset.questionId;
                    const questionType = container.dataset.questionType;
                    let valueApplied = false;

                    if (questionType === 'MultipleChoice') {
                        // Select random option
                        const radioButtons = Array.from(container.querySelectorAll(`input[name="question_${questionId}"]`));
                        if (radioButtons.length > 0) {
                            const randomIndex = Math.floor(Math.random() * radioButtons.length);
                            radioButtons[randomIndex].checked = true;
                            valueApplied = true;
                        }
                    } else if (questionType === 'LikertScale') {
                        // Select random likert value
                        const radioButtons = Array.from(container.querySelectorAll(`input[name="question_${questionId}"]`));
                        if (radioButtons.length > 0) {
                            const randomIndex = Math.floor(Math.random() * radioButtons.length);
                            radioButtons[randomIndex].checked = true;
                            valueApplied = true;
                        }
                    } else if (questionType === 'TrueFalse') {
                        // Randomly select true or false
                        const options = [
                            container.querySelector(`input[name="question_${questionId}"][value="true"]`),
                            container.querySelector(`input[name="question_${questionId}"][value="false"]`)
                        ].filter(Boolean);

                        if (options.length > 0) {
                            const randomIndex = Math.floor(Math.random() * options.length);
                            options[randomIndex].checked = true;
                            valueApplied = true;
                        }
                    } else if (questionType === 'ShortText') {
                        // Generate random short text
                        const textInput = container.querySelector(`input[type="text"][name="question_${questionId}"]`);
                        if (textInput) {
                            textInput.value = `Ù¾Ø§Ø³Ø® Ø±Ù†Ø¯ÙˆÙ… ${Math.floor(Math.random() * 1000)}`;
                            valueApplied = true;
                        }
                    } else if (questionType === 'LongText') {
                        // Generate random long text
                        const textarea = container.querySelector(`textarea[name="question_${questionId}"]`);
                        if (textarea) {
                            textarea.value = `Ø§ÛŒÙ† ÛŒÚ© Ù¾Ø§Ø³Ø® Ø±Ù†Ø¯ÙˆÙ… Ø§Ø³Øª Ø¨Ø±Ø§ÛŒ Ø³ÙˆØ§Ù„ Ø´Ù…Ø§Ø±Ù‡ ${i + 1}. Ù…ØªÙ† ØªØµØ§Ø¯ÙÛŒ: ${Math.random().toString(36).substring(7)}`;
                            valueApplied = true;
                        }
                    }

                    if (!valueApplied) {
                        console.warn(`âš ï¸ Skipped question ${questionId} because no input was found for type ${questionType}.`);
                        continue;
                    }

                    const saved = await saveAnswer(container);
                    if (saved) {
                        answeredCount++;
                        container.classList.remove('border-danger');
                    } else {
                        container.classList.add('border-danger');
                        console.warn(`âš ï¸ Failed to persist auto-generated answer for question ${questionId}.`);
                    }

                    updateProgressBar();

                    // Wait briefly after each question to avoid overwhelming the server
                    await new Promise(resolve => setTimeout(resolve, 75));

                    // Show progress every 20 questions
                    if (autoCompleteBtn && (i + 1) % 20 === 0) {
                        console.log(`âœ… Processed ${i + 1}/${questionContainers.length} questions...`);
                        autoCompleteBtn.innerHTML = `<i class="bi bi-hourglass-split"></i> ${i + 1}/${questionContainers.length}`;
                    }
                }

                // Wait a bit for all saves to complete
                await new Promise(resolve => setTimeout(resolve, 500));

                // Update progress bar
                updateProgressBar();

                // Show success message
                alert(`âœ… ØªÚ©Ù…ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯!\n\n${answeredCount} Ø³ÙˆØ§Ù„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯.\n\nØ­Ø§Ù„Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¢Ø²Ù…ÙˆÙ† Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯.`);

                // Scroll to bottom to show submit button
                const submitBtn = document.getElementById('submitBtn');
                if (submitBtn) {
                    submitBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
            finally {
                if (autoCompleteBtn) {
                    autoCompleteBtn.disabled = false;
                    autoCompleteBtn.innerHTML = originalButtonLabel || '<i class="bi bi-lightning-charge"></i> ØªÚ©Ù…ÛŒÙ„ Ø®ÙˆØ¯Ú©Ø§Ø±';
                }
            }
        }

        window.autoCompleteTest = autoCompleteTest;
    </script>
}

@functions {
    private static AssessmentQuestionMetadata? GetAssessmentMetadata(string? explanation)
    {
        if (string.IsNullOrWhiteSpace(explanation))
        {
            return null;
        }

        try
        {
            return JsonSerializer.Deserialize<AssessmentQuestionMetadata>(explanation);
        }
        catch
        {
            return null;
        }
    }

    private static string GetAssessmentSectionLabel(string? assessmentKey)
    {
        if (string.IsNullOrWhiteSpace(assessmentKey))
        {
            return string.Empty;
        }

        return assessmentKey.Trim().ToLowerInvariant() switch
        {
            "clifton" => "Ø¨Ø®Ø´ Clifton (Ø§Ø³ØªØ¹Ø¯Ø§Ø¯Ù‡Ø§)",
            "pvq" => "Ø¨Ø®Ø´ Schwartz PVQ",
            _ => string.Empty
        };
    }
}
